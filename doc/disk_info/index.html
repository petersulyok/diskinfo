<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>disk_info API documentation</title>
<meta name="description" content="This Python package can discover and collect disk information on Linux. It can also provide persistent disk names
for stable device referencing …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>disk_info</code></h1>
</header>
<section id="section-intro">
<p>This Python package can discover and collect disk information on Linux. It can also provide persistent disk names
for stable device referencing.</p>
<h1 id="installation">Installation</h1>
<p>Standard installation from <code>pypi.org</code>:</p>
<pre><code>pip install disk_info
</code></pre>
<p>The package does not have extra dependencies.</p>
<h1 id="how-to-use">How to use</h1>
<p>There are two different ways how this package can be used. Either you can collect information about a specific disk
or you can discover all existing disks on your system.</p>
<h2 id="option-1-collect-information-about-a-disk">Option 1: collect information about a disk</h2>
<p>Information can be collected about a specific disk with the creation of an <code><a title="disk_info.Disk" href="#disk_info.Disk">Disk</a></code> class instance. Here the caller has
to provide a unique identifier for the disk. Disk information will be collected at class creation time then the user
can call several member functions to get collected attributes.</p>
<pre><code>&gt;&gt;&gt; from disk_info import Disk
&gt;&gt;&gt; d = Disk("sda")
&gt;&gt;&gt; d.get_model()
'Samsung SSD 870 QVO 8TB'
&gt;&gt;&gt; d.is_ssd()
True
&gt;&gt;&gt; s, u = d.get_size_in_hrf()
&gt;&gt;&gt; print(f"{s:.1f} {u}")
8.0 TB
&gt;&gt;&gt; d.get_serial()
'S5SXNG0MB01829M'
</code></pre>
<p>See the complete list of the class methods in documentation of class <code><a title="disk_info.Disk" href="#disk_info.Disk">Disk</a></code>.</p>
<h2 id="option-2-discover-disks">Option 2: discover disks</h2>
<p>Disk can be discovered by creation of an instance of the class <code><a title="disk_info.DiskInfo" href="#disk_info.DiskInfo">DiskInfo</a></code>. After having an instance of DiskInfo class
the list and the number of identified disks can be queried with <code>get_disk_number()</code> and <code>get_disk_list()</code> functions:</p>
<pre><code>&gt;&gt;&gt; from disk_info import Disk, DiskInfo
&gt;&gt;&gt; di = DiskInfo()
&gt;&gt;&gt; di.get_disk_number()
4
&gt;&gt;&gt; disks = di.get_disk_list(sorting=True)
&gt;&gt;&gt; for d in disks:
&gt;&gt;&gt;     print(d.get_path())
/dev/nvme0n1
/dev/sda
/dev/sdb
/dev/sdc
</code></pre>
<p>The caller can apply filters (included and ecluded disk types) for both functions. The list of disk can be also sorted.</p>
<h1 id="persistent-disk-names">Persistent disk names</h1>
<p>Please note that not all kind of block device names are persistent. For example this disk path</p>
<pre><code> "/dev/sdb"
</code></pre>
<p>could refer different physical disk after a reboot. That is reason why other persistent names have been introduced in
Linux and udev. The physical device can be referenced by the following path type:</p>
<pre><code> "/dev/disk/by-id/nvme-WDS80T1X06-00AFY1_2130GF574294"
</code></pre>
<p>This type of reference is called <code>by-id</code> path in this documentation. The physical connector (i.e. where the disck is
connected) can be also referenced with the following path:</p>
<pre><code> "/dev/disk/by-path/pci-0000:02:00.0-nvme-1"
</code></pre>
<p>This type of reference is called <code>by-path</code> path in this documentation. Both references are persistent and
safe in disk referencing.</p>
<p>Read more about this topic at [Arch Linux wiki: Persistent block device naming] (<a href="https://wiki.archlinux.org/title/persistent_block_device_naming">https://wiki.archlinux.org/title/persistent_block_device_naming</a>).</p>
<h1 id="demo">Demo</h1>
<p>There is a simple demo included in the package. You can execute it with in the following way:</p>
<pre><code> python -m disk_info.demo
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This Python package can discover and collect disk information on Linux. It can also provide persistent disk names
for stable device referencing.

Installation
============
Standard installation from `pypi.org`:

    pip install disk_info

The package does not have extra dependencies.

How to use
==========
There are two different ways how this package can be used. Either you can collect information about a specific disk
or you can discover all existing disks on your system.

Option 1: collect information about a disk
------------------------------------------
Information can be collected about a specific disk with the creation of an `Disk` class instance. Here the caller has
to provide a unique identifier for the disk. Disk information will be collected at class creation time then the user
can call several member functions to get collected attributes.

    &gt;&gt;&gt; from disk_info import Disk
    &gt;&gt;&gt; d = Disk(&#34;sda&#34;)
    &gt;&gt;&gt; d.get_model()
    &#39;Samsung SSD 870 QVO 8TB&#39;
    &gt;&gt;&gt; d.is_ssd()
    True
    &gt;&gt;&gt; s, u = d.get_size_in_hrf()
    &gt;&gt;&gt; print(f&#34;{s:.1f} {u}&#34;)
    8.0 TB
    &gt;&gt;&gt; d.get_serial()
    &#39;S5SXNG0MB01829M&#39;

See the complete list of the class methods in documentation of class `Disk`.

Option 2: discover disks
------------------------
Disk can be discovered by creation of an instance of the class `DiskInfo`. After having an instance of DiskInfo class
the list and the number of identified disks can be queried with `get_disk_number()` and `get_disk_list()` functions:

    &gt;&gt;&gt; from disk_info import Disk, DiskInfo
    &gt;&gt;&gt; di = DiskInfo()
    &gt;&gt;&gt; di.get_disk_number()
    4
    &gt;&gt;&gt; disks = di.get_disk_list(sorting=True)
    &gt;&gt;&gt; for d in disks:
    &gt;&gt;&gt;     print(d.get_path())
    /dev/nvme0n1
    /dev/sda
    /dev/sdb
    /dev/sdc

The caller can apply filters (included and ecluded disk types) for both functions. The list of disk can be also sorted.

Persistent disk names
=====================
Please note that not all kind of block device names are persistent. For example this disk path

     &#34;/dev/sdb&#34;

could refer different physical disk after a reboot. That is reason why other persistent names have been introduced in
Linux and udev. The physical device can be referenced by the following path type:

     &#34;/dev/disk/by-id/nvme-WDS80T1X06-00AFY1_2130GF574294&#34;

This type of reference is called `by-id` path in this documentation. The physical connector (i.e. where the disck is
connected) can be also referenced with the following path:

     &#34;/dev/disk/by-path/pci-0000:02:00.0-nvme-1&#34;

This type of reference is called `by-path` path in this documentation. Both references are persistent and
safe in disk referencing.

Read more about this topic at [Arch Linux wiki: Persistent block device naming] \
(https://wiki.archlinux.org/title/persistent_block_device_naming).

Demo
====
There is a simple demo included in the package. You can execute it with in the following way:

     python -m disk_info.demo

&#34;&#34;&#34;
from disk_info.disk import Disk, DiskType
from disk_info.disk_info import DiskInfo

__all__ = [&#34;Disk&#34;, &#34;DiskType&#34;, &#34;DiskInfo&#34;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="disk_info.demo" href="demo.html">disk_info.demo</a></code></dt>
<dd>
<div class="desc"><p>Module <code><a title="disk_info.demo" href="demo.html">disk_info.demo</a></code>: implements a simple demo about use of this package.
Peter Sulyok (C) 2022</p></div>
</dd>
<dt><code class="name"><a title="disk_info.disk" href="disk.html">disk_info.disk</a></code></dt>
<dd>
<div class="desc"><p>Module <code><a title="disk_info.disk" href="disk.html">disk_info.disk</a></code>: implements classes <code><a title="disk_info.DiskType" href="#disk_info.DiskType">DiskType</a></code> and <code><a title="disk_info.Disk" href="#disk_info.Disk">Disk</a></code>.
Peter Sulyok (C) 2022</p></div>
</dd>
<dt><code class="name"><a title="disk_info.disk_info" href="disk_info.html">disk_info.disk_info</a></code></dt>
<dd>
<div class="desc"><p>Module <code><a title="disk_info.disk_info" href="disk_info.html">disk_info.disk_info</a></code>: implements class <code><a title="disk_info.DiskInfo" href="#disk_info.DiskInfo">DiskInfo</a></code>.
Peter Sulyok (C) 2022</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="disk_info.Disk"><code class="flex name class">
<span>class <span class="ident">Disk</span></span>
<span>(</span><span>disk_name: str = None, byid_name: str = None, bypath_name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Disk class implementation.</p>
<p>The class can be initialized with specifying one unique identifier of the disk. Based on this identifier
the adequate disk information will be collected
(from <code>/sys</code> and <code>udev</code> system data) and stored in the class.
One of the input parameters MUST be specified otherwise ValueError exception will be raised. During the class
initialization the disk will not be directly accessed, so its power state will not be changed (e.g. will not
be awakened from a <code>STANDBY</code> state).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>disk_name</code></strong> :&ensp;<code>str</code></dt>
<dd>disk name (e.g. <code>sda</code> or <code>nvme0n1</code>) located in directory <code>/dev/</code>.</dd>
<dt><strong><code>byid_name</code></strong> :&ensp;<code>str</code></dt>
<dd>by-id name of the disk (e.g. <code>ata-WDC_WD320GLAX-68UNT16_A9HM3FTY</code>) located in
directory <code>/dev/disk/by-id/</code>.</dd>
<dt><strong><code>bypath_name</code></strong> :&ensp;<code>str</code></dt>
<dd>by-path name of the disk (e.g. <code>pci-0000:00:17.0-ata-1</code>) located in
directory <code>/dev/disk/by-path/</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>in case of missing or invalid parameters</dd>
<dt><code>RuntimeError</code></dt>
<dd>in case of any system error</dd>
</dl>
<h2 id="example">Example</h2>
<p>A simple example of use:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from disk_info import Disk
&gt;&gt;&gt; d = Disk(&quot;sda&quot;)
&gt;&gt;&gt; d.get_path()
'/dev/sda'
&gt;&gt;&gt; d.get_serial()
'S3D2NY0J819210S'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Disk:
    &#34;&#34;&#34;Disk class implementation.&#34;&#34;&#34;
    __name: str                         # Disk name (e.g. sda)
    __path: str                         # Disk path (e.g. /dev/sda)
    __byid_path: List[str]              # Disk by-byid paths (e.g. /dev/disk/by-byid/ata-WDC_WD80FLAX...)
    __bypath_path: List[str]            # Disk by-path paths (e.g. /dev/disk/by-path/pci-0000:00:17.0-ata-1)
    __wwn: str                          # Disk WWN byid
    __dev_id: str                       # Disk device id (e.g. 8:0)
    __model: str                        # Disk model name
    __serial_number: str                # Disk serial number
    __firmware: str                     # Disk firmware
    __type: int                         # Disk type (HDD, SSD or NVME)
    __size: int                         # Disk size (number of 512-byte blocks)
    __physical_block_size: int          # Disk physical block size
    __logical_block_size: int           # Disk logical block size
    __part_table_type: str              # Disk partition table type
    __part_table_uuid: str              # Disk partition table UUID
    __device_hwmon_path: str            # Path of the hwmon temperature file

    def __init__(self, disk_name: str = None, byid_name: str = None, bypath_name: str = None) -&gt; None:
        &#34;&#34;&#34;The class can be initialized with specifying one unique identifier of the disk. Based on this identifier
        the adequate disk information will be collected  (from `/sys` and `udev` system data) and stored in the class.
        One of the input parameters MUST be specified otherwise ValueError exception will be raised. During the class
        initialization the disk will not be directly accessed, so its power state will not be changed (e.g. will not
        be awakened from a `STANDBY` state).

        Args:
            disk_name (str): disk name (e.g. `sda` or `nvme0n1`) located in directory `/dev/`.
            byid_name (str): by-id name of the disk (e.g. `ata-WDC_WD320GLAX-68UNT16_A9HM3FTY`) located in
                             directory `/dev/disk/by-id/`.
            bypath_name (str): by-path name of the disk (e.g. `pci-0000:00:17.0-ata-1`) located in
                               directory `/dev/disk/by-path/`.

        Raises:
            ValueError: in case of missing or invalid parameters
            RuntimeError: in case of any system error

        Example:
            A simple example of use:

            &gt;&gt;&gt; from disk_info import Disk
            &gt;&gt;&gt; d = Disk(&#34;sda&#34;)
            &gt;&gt;&gt; d.get_path()
            &#39;/dev/sda&#39;
            &gt;&gt;&gt; d.get_serial()
            &#39;S3D2NY0J819210S&#39;
         &#34;&#34;&#34;
        # Identify disk name and path.
        if disk_name:
            # Save disk name and check device path.
            self.__name = disk_name
            self.__path = &#34;/dev/&#34; + disk_name
        elif byid_name:
            self.__name = os.path.basename(os.readlink(&#34;/dev/disk/by-id/&#34; + byid_name))
            self.__path = &#34;/dev/&#34; + self.__name
        elif bypath_name:
            self.__name = os.path.basename(os.readlink(&#34;/dev/disk/by-path/&#34; + bypath_name))
            self.__path = &#34;/dev/&#34; + self.__name
        else:
            raise ValueError(&#34;Missing initializer parameter, Disk() class cannot be initialized.&#34;)

        # Check the existence of disk name in /dev and /sys/block folders.
        if not os.path.exists(self.__path):
            raise ValueError(&#34;Disk path (&#34; + self.__path + &#34;) does not exist!&#34;)
        path = &#34;/sys/block/&#34; + self.__name
        if not os.path.exists(path):
            raise ValueError(&#34;Disk path (&#34; + path + &#34;) does not exist!&#34;)

        # Determine disk type (HDD, SSD, NVME)
        path = &#34;/sys/block/&#34; + self.__name + &#34;/queue/rotational&#34;
        result = self._read_file(path)
        if result == &#34;1&#34;:
            self.__type = DiskType.HDD
        elif result == &#34;0&#34;:
            self.__type = DiskType.SSD
        else:
            raise RuntimeError(&#34;Disk type cannot be determined based on this value (&#34; + path + &#34;=&#34; + result + &#34;).&#34;)
        if &#34;nvme&#34; in self.__name:
            self.__type = DiskType.NVME

        # Read attributes from /sys filesystem and from udev.
        self.__size = int(self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/size&#34;))
        self.__model = self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/device/model&#34;)
        self.__dev_id = self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/dev&#34;)
        self.__physical_block_size = int(self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/queue/physical_block_size&#34;))
        self.__logical_block_size = int(self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/queue/logical_block_size&#34;))
        self.__serial_number = self._read_udev_property(&#34;ID_SERIAL_SHORT=&#34;)
        self.__firmware = self._read_udev_property(&#34;ID_REVISION=&#34;)
        self.__wwn = self._read_udev_property(&#34;ID_WWN=&#34;)
        self.__part_table_type = self._read_udev_property(&#34;ID_PART_TABLE_TYPE=&#34;)
        self.__part_table_uuid = self._read_udev_property(&#34;ID_PART_TABLE_UUID=&#34;)
        model = self._read_udev_property(&#34;ID_MODEL_ENC=&#34;)
        if model:
            self.__model = model

        # Read `/dev/disk/by-byid/` path elements from udev and check their existence.
        self.__byid_path = self._read_udev_path(True)
        for file_name in self.__byid_path:
            if not os.path.exists(file_name):
                raise RuntimeError(&#34;Disk by-id path (&#34; + file_name + &#34;) does not exist!&#34;)

        # Read `/dev/disk/by-path/` path elements from udev and check their existence.
        self.__bypath_path = self._read_udev_path(False)
        for file_name in self.__bypath_path:
            if not os.path.exists(file_name):
                raise RuntimeError(&#34;Disk by-path path (&#34; + file_name + &#34;) does not exist!&#34;)

    def get_name(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk name.&#34;&#34;&#34;
        return self.__name

    def get_path(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk path. Please note this path is not persistent.&#34;&#34;&#34;
        return self.__path

    def get_byid_path(self) -&gt; List[str]:
        &#34;&#34;&#34;Returns the disk path elements in a persistent `/dev/disk/by-byid/...` form.
        The result could be one or more path elements.&#34;&#34;&#34;
        return self.__byid_path

    def get_bypath_path(self) -&gt; List[str]:
        &#34;&#34;&#34;Returns the disk path elements in a persistent `/dev/disk/by-path/...` form.
        The result could be one or more path elements.&#34;&#34;&#34;
        return self.__bypath_path

    def get_wwn(self) -&gt; str:
        &#34;&#34;&#34;Returns the WWN name of the disk. Read more about
        [WWN names here](https://en.wikipedia.org/wiki/World_Wide_Name).&#34;&#34;&#34;
        return self.__wwn

    def get_dev_id(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk device id.&#34;&#34;&#34;
        return self.__dev_id

    def get_model(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk model.&#34;&#34;&#34;
        return self.__model

    def get_serial(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk serial number.&#34;&#34;&#34;
        return self.__serial_number

    def get_firmware(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk firmware.&#34;&#34;&#34;
        return self.__firmware

    def get_type(self) -&gt; int:
        &#34;&#34;&#34;Returns the type of the disk.&#34;&#34;&#34;
        return self.__type

    def get_type_str(self) -&gt; str:
        &#34;&#34;&#34;Returns the name of the disk type.&#34;&#34;&#34;
        if self.is_nvme():
            return DiskType.NVME_STR
        if self.is_ssd():
            return DiskType.SSD_STR
        return DiskType.HDD_STR

    def is_ssd(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the disk type is SSD, otherwise False.&#34;&#34;&#34;
        return bool(self.__type == DiskType.SSD)

    def is_nvme(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the disk type is NVME, otherwise False.&#34;&#34;&#34;
        return bool(self.__type == DiskType.NVME)

    def is_hdd(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the disk type is HDD, otherwise False.&#34;&#34;&#34;
        return bool(self.__type == DiskType.HDD)

    def get_size(self) -&gt; int:
        &#34;&#34;&#34;Returns the size of the disk in 512-byte units.&#34;&#34;&#34;
        return self.__size

    def get_size_in_hrf(self, units: int = 0) -&gt; Tuple[float, str]:
        &#34;&#34;&#34;Returns the size of the disk in a human-readable form (e.g. &#34;1 TB&#34;).

        Args:
            units (int): unit system will be used in result (0-metric units (default), 1 - IEC units,
                         2-legacy units). Read more about [units here](https://en.wikipedia.org/wiki/Byte).

        Returns:
            Tuple[float, str]: size of the disk, proper unit
        &#34;&#34;&#34;
        metric_units: List[str] = [&#34;B&#34;, &#34;kB&#34;, &#34;MB&#34;, &#34;GB&#34;, &#34;TB&#34;, &#34;PB&#34;, &#34;EB&#34;]
        iec_units: List[str] = [&#34;B&#34;, &#34;KiB&#34;, &#34;MiB&#34;, &#34;GiB&#34;, &#34;TiB&#34;, &#34;PiB&#34;, &#34;EiB&#34;]
        legacy_units: List[str] = [&#34;B&#34;, &#34;KB&#34;, &#34;MB&#34;, &#34;GB&#34;, &#34;TB&#34;, &#34;PB&#34;, &#34;EB&#34;]
        divider: int    # Divider for the specified unit.
        size: float     # Result size
        unit: str       # Result unit
        i: int = 0      # Unit index

        # Set up the proper divider.
        if units == 0:
            divider = 1000
        elif units == 1:
            divider = 1024
        else:
            divider = 1024

        # Calculate the proper disk size.
        size = self.__size * 512
        number_of_units = len(metric_units)
        for i in range(number_of_units):
            if size &lt; divider:
                break
            size /= divider

        # Identify the proper unit for the calculated size.
        if units == 0:
            unit = metric_units[i]
        elif units == 1:
            unit = iec_units[i]
        else:
            unit = legacy_units[i]

        return size, unit

    def get_physical_block_size(self) -&gt; int:
        &#34;&#34;&#34;Returns the physical block size in bytes.&#34;&#34;&#34;
        return self.__physical_block_size

    def get_logical_block_size(self) -&gt; int:
        &#34;&#34;&#34;Returns the logical block size in bytes.&#34;&#34;&#34;
        return self.__logical_block_size

    def get_partition_table_type(self) -&gt; str:
        &#34;&#34;&#34;Returns the type of the partition table.&#34;&#34;&#34;
        return self.__part_table_type

    def get_partition_table_uuid(self) -&gt; str:
        &#34;&#34;&#34;Returns the UUID of the partition table.&#34;&#34;&#34;
        return self.__part_table_uuid

    @staticmethod
    def _read_file(path) -&gt; str:
        &#34;&#34;&#34;Reads the text content of the specified file. The function will hide IOError and FileNotFound exceptions
         during the file operation. The result string will be decoded (UTF-8) and stripped.

        Args:
            path (str): file path

        Returns:
            str: file content text
        &#34;&#34;&#34;
        result: str = &#34;&#34;
        try:
            with open(path, &#34;rt&#34;, encoding=&#34;UTF-8&#34;) as file:
                result = file.read()
        except (IOError, FileNotFoundError):
            pass
        return result.strip()

    def _read_udev_property(self, udev_property: str) -&gt; str:
        &#34;&#34;&#34;Reads a property from udev data file belonging to the disk (/run/udev/data/b?:?).
        It will hide IOError and FileNotFound exceptions during the file operation. The result string
        will be decoded and stripped.

        Args:
            udev_property (str): udev property string

        Returns:
            str: value of the property
        &#34;&#34;&#34;
        file_content: List[str] = []
        result: str = &#34;&#34;

        # Read proper udev data file.
        try:
            path = &#34;/run/udev/data/b&#34; + self.__dev_id
            with open(path, &#34;rt&#34;, encoding=&#34;unicode_escape&#34;) as file:
                file_content = file.read().splitlines()
        except (IOError, FileNotFoundError):
            pass

        # Find the specified udev_property and copy its value.
        for lines in file_content:
            pos = lines.find(udev_property)
            if pos != -1:
                result = lines[pos+len(udev_property):]

        return result.strip()

    def _read_udev_path(self, byid: bool) -&gt; List[str]:
        &#34;&#34;&#34;Reads one or more path elements from udev data file belonging to the disk (/run/udev/data/b?:?).
        It will hide any IO exception during the file operation.

        Args:
            byid (bool):
                True: `by-id` path elements will be loaded
                False: `by-path` path elements will be loaded
        Returns:
            List[str]: path elements
        &#34;&#34;&#34;
        path: str
        file_content: List[str] = []
        result: List[str] = []
        udev_property: str

        # Read proper udev data file.
        try:
            path = &#34;/run/udev/data/b&#34; + self.__dev_id
            with open(path, &#34;rt&#34;, encoding=&#34;UTF-8&#34;) as file:
                file_content = file.read().splitlines()
        except (IOError, FileNotFoundError):
            pass

        # Find the specified path elements and collect their value.
        if byid:
            udev_property = &#34;disk/by-id/&#34;
        else:
            udev_property = &#34;disk/by-path/&#34;
        for lines in file_content:
            pos = lines.find(udev_property)
            if pos != -1:
                result.append(&#34;/dev/&#34; + lines[pos:].strip())

        return result

    def __gt__(self, other) -&gt; bool:
        &#34;&#34;&#34;Implementation of &#39;&gt;&#39; operator for Disk class.&#34;&#34;&#34;
        return bool(self.__name &gt; other.__name)

    def __lt__(self, other) -&gt; bool:
        &#34;&#34;&#34;Implementation of &#39;&lt;&#39; operator for Disk class.&#34;&#34;&#34;
        return bool(self.__name &lt; other.__name)

    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;Implementation of &#39;==&#39; operator for Disk class.&#34;&#34;&#34;
        return bool(self.__name == other.__name)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="disk_info.Disk.get_byid_path"><code class="name flex">
<span>def <span class="ident">get_byid_path</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk path elements in a persistent <code>/dev/disk/by-byid/...</code> form.
The result could be one or more path elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_byid_path(self) -&gt; List[str]:
    &#34;&#34;&#34;Returns the disk path elements in a persistent `/dev/disk/by-byid/...` form.
    The result could be one or more path elements.&#34;&#34;&#34;
    return self.__byid_path</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_bypath_path"><code class="name flex">
<span>def <span class="ident">get_bypath_path</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk path elements in a persistent <code>/dev/disk/by-path/...</code> form.
The result could be one or more path elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bypath_path(self) -&gt; List[str]:
    &#34;&#34;&#34;Returns the disk path elements in a persistent `/dev/disk/by-path/...` form.
    The result could be one or more path elements.&#34;&#34;&#34;
    return self.__bypath_path</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_dev_id"><code class="name flex">
<span>def <span class="ident">get_dev_id</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk device id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dev_id(self) -&gt; str:
    &#34;&#34;&#34;Returns the disk device id.&#34;&#34;&#34;
    return self.__dev_id</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_firmware"><code class="name flex">
<span>def <span class="ident">get_firmware</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk firmware.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_firmware(self) -&gt; str:
    &#34;&#34;&#34;Returns the disk firmware.&#34;&#34;&#34;
    return self.__firmware</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_logical_block_size"><code class="name flex">
<span>def <span class="ident">get_logical_block_size</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the logical block size in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_logical_block_size(self) -&gt; int:
    &#34;&#34;&#34;Returns the logical block size in bytes.&#34;&#34;&#34;
    return self.__logical_block_size</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_model"><code class="name flex">
<span>def <span class="ident">get_model</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model(self) -&gt; str:
    &#34;&#34;&#34;Returns the disk model.&#34;&#34;&#34;
    return self.__model</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_name(self) -&gt; str:
    &#34;&#34;&#34;Returns the disk name.&#34;&#34;&#34;
    return self.__name</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_partition_table_type"><code class="name flex">
<span>def <span class="ident">get_partition_table_type</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the type of the partition table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partition_table_type(self) -&gt; str:
    &#34;&#34;&#34;Returns the type of the partition table.&#34;&#34;&#34;
    return self.__part_table_type</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_partition_table_uuid"><code class="name flex">
<span>def <span class="ident">get_partition_table_uuid</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the UUID of the partition table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partition_table_uuid(self) -&gt; str:
    &#34;&#34;&#34;Returns the UUID of the partition table.&#34;&#34;&#34;
    return self.__part_table_uuid</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_path"><code class="name flex">
<span>def <span class="ident">get_path</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk path. Please note this path is not persistent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path(self) -&gt; str:
    &#34;&#34;&#34;Returns the disk path. Please note this path is not persistent.&#34;&#34;&#34;
    return self.__path</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_physical_block_size"><code class="name flex">
<span>def <span class="ident">get_physical_block_size</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the physical block size in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_physical_block_size(self) -&gt; int:
    &#34;&#34;&#34;Returns the physical block size in bytes.&#34;&#34;&#34;
    return self.__physical_block_size</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_serial"><code class="name flex">
<span>def <span class="ident">get_serial</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk serial number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_serial(self) -&gt; str:
    &#34;&#34;&#34;Returns the disk serial number.&#34;&#34;&#34;
    return self.__serial_number</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the size of the disk in 512-byte units.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size(self) -&gt; int:
    &#34;&#34;&#34;Returns the size of the disk in 512-byte units.&#34;&#34;&#34;
    return self.__size</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_size_in_hrf"><code class="name flex">
<span>def <span class="ident">get_size_in_hrf</span></span>(<span>self, units: int = 0) ‑> Tuple[float, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the size of the disk in a human-readable form (e.g. "1 TB").</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>units</code></strong> :&ensp;<code>int</code></dt>
<dd>unit system will be used in result (0-metric units (default), 1 - IEC units,
2-legacy units). Read more about <a href="https://en.wikipedia.org/wiki/Byte">units here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[float, str]</code></dt>
<dd>size of the disk, proper unit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size_in_hrf(self, units: int = 0) -&gt; Tuple[float, str]:
    &#34;&#34;&#34;Returns the size of the disk in a human-readable form (e.g. &#34;1 TB&#34;).

    Args:
        units (int): unit system will be used in result (0-metric units (default), 1 - IEC units,
                     2-legacy units). Read more about [units here](https://en.wikipedia.org/wiki/Byte).

    Returns:
        Tuple[float, str]: size of the disk, proper unit
    &#34;&#34;&#34;
    metric_units: List[str] = [&#34;B&#34;, &#34;kB&#34;, &#34;MB&#34;, &#34;GB&#34;, &#34;TB&#34;, &#34;PB&#34;, &#34;EB&#34;]
    iec_units: List[str] = [&#34;B&#34;, &#34;KiB&#34;, &#34;MiB&#34;, &#34;GiB&#34;, &#34;TiB&#34;, &#34;PiB&#34;, &#34;EiB&#34;]
    legacy_units: List[str] = [&#34;B&#34;, &#34;KB&#34;, &#34;MB&#34;, &#34;GB&#34;, &#34;TB&#34;, &#34;PB&#34;, &#34;EB&#34;]
    divider: int    # Divider for the specified unit.
    size: float     # Result size
    unit: str       # Result unit
    i: int = 0      # Unit index

    # Set up the proper divider.
    if units == 0:
        divider = 1000
    elif units == 1:
        divider = 1024
    else:
        divider = 1024

    # Calculate the proper disk size.
    size = self.__size * 512
    number_of_units = len(metric_units)
    for i in range(number_of_units):
        if size &lt; divider:
            break
        size /= divider

    # Identify the proper unit for the calculated size.
    if units == 0:
        unit = metric_units[i]
    elif units == 1:
        unit = iec_units[i]
    else:
        unit = legacy_units[i]

    return size, unit</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_type"><code class="name flex">
<span>def <span class="ident">get_type</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the type of the disk.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type(self) -&gt; int:
    &#34;&#34;&#34;Returns the type of the disk.&#34;&#34;&#34;
    return self.__type</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_type_str"><code class="name flex">
<span>def <span class="ident">get_type_str</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the disk type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_str(self) -&gt; str:
    &#34;&#34;&#34;Returns the name of the disk type.&#34;&#34;&#34;
    if self.is_nvme():
        return DiskType.NVME_STR
    if self.is_ssd():
        return DiskType.SSD_STR
    return DiskType.HDD_STR</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.get_wwn"><code class="name flex">
<span>def <span class="ident">get_wwn</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the WWN name of the disk. Read more about
<a href="https://en.wikipedia.org/wiki/World_Wide_Name">WWN names here</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_wwn(self) -&gt; str:
    &#34;&#34;&#34;Returns the WWN name of the disk. Read more about
    [WWN names here](https://en.wikipedia.org/wiki/World_Wide_Name).&#34;&#34;&#34;
    return self.__wwn</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.is_hdd"><code class="name flex">
<span>def <span class="ident">is_hdd</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the disk type is HDD, otherwise False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_hdd(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if the disk type is HDD, otherwise False.&#34;&#34;&#34;
    return bool(self.__type == DiskType.HDD)</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.is_nvme"><code class="name flex">
<span>def <span class="ident">is_nvme</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the disk type is NVME, otherwise False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_nvme(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if the disk type is NVME, otherwise False.&#34;&#34;&#34;
    return bool(self.__type == DiskType.NVME)</code></pre>
</details>
</dd>
<dt id="disk_info.Disk.is_ssd"><code class="name flex">
<span>def <span class="ident">is_ssd</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the disk type is SSD, otherwise False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_ssd(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if the disk type is SSD, otherwise False.&#34;&#34;&#34;
    return bool(self.__type == DiskType.SSD)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="disk_info.DiskInfo"><code class="flex name class">
<span>class <span class="ident">DiskInfo</span></span>
</code></dt>
<dd>
<div class="desc"><p>DisksInfo class implementation.</p>
<p>At class initialization time all existing disks will be discovered in the system. After this,
the number of identified disk can be queried with method <code>get_disk_number()</code> and the list of the identified
disks can be also queried with method <code>get_disk_list()</code>. In both cases disk type filters can be
applied to query only the subset of the discovered disks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DiskInfo:
    &#34;&#34;&#34; DisksInfo class implementation.&#34;&#34;&#34;

    __disk_list: List[Disk]           # List of discovered disks.

    def __init__(self):
        &#34;&#34;&#34;At class initialization time all existing disks will be discovered in the system. After this,
        the number of identified disk can be queried with method `get_disk_number()` and the list of the identified
        disks can be also queried with method `get_disk_list()`. In both cases disk type filters can be
        applied to query only the subset of the discovered disks.&#34;&#34;&#34;

        # Initialize class variables.
        self.__disk_list = []

        # Iterate on list of block devices.
        for file_name in os.listdir(&#39;/sys/block&#39;):
            new_disk = Disk(disk_name=file_name)
            self.__disk_list.append(new_disk)

    def get_disk_number(self, included: set = None, excluded: set = None) -&gt; int:
        &#34;&#34;&#34;Returns the number of the disks. The caller can specify inclusive and exclusice filters for disk types.
        If no filters are specified then the default behaviour is to include all disk types and to exclude nothing.

        Args:
            included (set): filter set for included disk types
            excluded (set): filter set for excluded disk types
        Returns:
            int: number of the (filtered) disks
        Raises:
            ValueError: if there are common disk types on included and excluded filter sets
        Example:
            A code example about using filters: it counts the number of SSDs excluding NVME disks.

            &gt;&gt;&gt; from disk_info import DiskType, DiskInfo
            &gt;&gt;&gt; di = DiskInfo()
            &gt;&gt;&gt; n = di.get_disk_number(included={DiskType.SSD}, excluded={DiskType.NVME})
            &gt;&gt;&gt; print(f&#34;Number of SSDs: {n}&#34;)
            Number of SSDs: 3
        &#34;&#34;&#34;
        disk_number: int    # Number of disk counted

        # Set default filters if not specified.
        if not included:
            included = {DiskType.HDD, DiskType.SSD, DiskType.NVME}
        if not excluded:
            excluded = set()

        # Check invalid filters.
        if included.intersection(excluded):
            raise ValueError(&#34;Parameter error: same value on included and excluded list.&#34;)

        # Count number of disks based on the specified filters.
        disk_number = 0
        for disk in self.__disk_list:
            disk_type = disk.get_type()
            if disk_type in included and disk_type not in excluded:
                disk_number += 1

        return disk_number

    def get_disk_list(self, included: set = None, excluded: set = None, sorting: bool = False,
                      rev_order: bool = False) -&gt; List[Disk]:
        &#34;&#34;&#34;Returns the list of identified disks. The caller can specify inclusive and exclusice filters for disk types.
        If no filters are specified the default behaviour is to include all disk types and to exclude nothing.
        The list can be sorted based on the disk `name` in alphabetical order. Caller can also request sorting
        in reverse order.

        Args:
            included (set): filter set for included disk types
            excluded (set): filter set for excluded disk types
            sorting (bool): disk list will be sorted based on `name` string
            rev_order (bool): sorting in reverse order
        Returns:
            List[Disk]: list of the (filtered) disks
        Raises:
            ValueError: if there are common disk types on included and excluded filter sets
        Example:
            A code example about using filters and sorting: it will list the device path of the sorted list
            of the HDDs:

            &gt;&gt;&gt; from disk_info import DiskType, DiskInfo
            &gt;&gt;&gt; di = DiskInfo()
            &gt;&gt;&gt; disks = di.get_disk_list(included={DiskType.HDD}, sorting=True)
            &gt;&gt;&gt; for d in disks:
            ...     print(d.get_path())
            ...
            /dev/sda
            /dev/sdb
            /dev/sdc
        &#34;&#34;&#34;
        result: List[Disk] = []

        # Set default filters if not specified.
        if not included:
            included = {DiskType.HDD, DiskType.SSD, DiskType.NVME}
        if not excluded:
            excluded = set()

        # Check invalid filters.
        if included.intersection(excluded):
            raise ValueError(&#34;Parameter error: same value on included and excluded list.&#34;)

        # Collect selected disks based on the specified filters.
        for disk in self.__disk_list:
            disk_type = disk.get_type()
            if disk_type in included and disk_type not in excluded:
                result.append(disk)

        # Sort the result list if needed.
        if sorting:
            result.sort(reverse=rev_order)

        return result

    def __contains__(self, item):
        &#34;&#34;&#34;Returns True if a specified disk is in the discovered list of disk otherwise False.&#34;&#34;&#34;

        # Check identified list of disks if the specified disk can be found.
        for disk in self.__disk_list:
            if item.get_serial() == disk.get_serial():
                return True
        return False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="disk_info.DiskInfo.get_disk_list"><code class="name flex">
<span>def <span class="ident">get_disk_list</span></span>(<span>self, included: set = None, excluded: set = None, sorting: bool = False, rev_order: bool = False) ‑> List[<a title="disk_info.disk.Disk" href="disk.html#disk_info.disk.Disk">Disk</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list of identified disks. The caller can specify inclusive and exclusice filters for disk types.
If no filters are specified the default behaviour is to include all disk types and to exclude nothing.
The list can be sorted based on the disk <code>name</code> in alphabetical order. Caller can also request sorting
in reverse order.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>included</code></strong> :&ensp;<code>set</code></dt>
<dd>filter set for included disk types</dd>
<dt><strong><code>excluded</code></strong> :&ensp;<code>set</code></dt>
<dd>filter set for excluded disk types</dd>
<dt><strong><code>sorting</code></strong> :&ensp;<code>bool</code></dt>
<dd>disk list will be sorted based on <code>name</code> string</dd>
<dt><strong><code>rev_order</code></strong> :&ensp;<code>bool</code></dt>
<dd>sorting in reverse order</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="disk_info.Disk" href="#disk_info.Disk">Disk</a>]</code></dt>
<dd>list of the (filtered) disks</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if there are common disk types on included and excluded filter sets</dd>
</dl>
<h2 id="example">Example</h2>
<p>A code example about using filters and sorting: it will list the device path of the sorted list
of the HDDs:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from disk_info import DiskType, DiskInfo
&gt;&gt;&gt; di = DiskInfo()
&gt;&gt;&gt; disks = di.get_disk_list(included={DiskType.HDD}, sorting=True)
&gt;&gt;&gt; for d in disks:
...     print(d.get_path())
...
/dev/sda
/dev/sdb
/dev/sdc
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_disk_list(self, included: set = None, excluded: set = None, sorting: bool = False,
                  rev_order: bool = False) -&gt; List[Disk]:
    &#34;&#34;&#34;Returns the list of identified disks. The caller can specify inclusive and exclusice filters for disk types.
    If no filters are specified the default behaviour is to include all disk types and to exclude nothing.
    The list can be sorted based on the disk `name` in alphabetical order. Caller can also request sorting
    in reverse order.

    Args:
        included (set): filter set for included disk types
        excluded (set): filter set for excluded disk types
        sorting (bool): disk list will be sorted based on `name` string
        rev_order (bool): sorting in reverse order
    Returns:
        List[Disk]: list of the (filtered) disks
    Raises:
        ValueError: if there are common disk types on included and excluded filter sets
    Example:
        A code example about using filters and sorting: it will list the device path of the sorted list
        of the HDDs:

        &gt;&gt;&gt; from disk_info import DiskType, DiskInfo
        &gt;&gt;&gt; di = DiskInfo()
        &gt;&gt;&gt; disks = di.get_disk_list(included={DiskType.HDD}, sorting=True)
        &gt;&gt;&gt; for d in disks:
        ...     print(d.get_path())
        ...
        /dev/sda
        /dev/sdb
        /dev/sdc
    &#34;&#34;&#34;
    result: List[Disk] = []

    # Set default filters if not specified.
    if not included:
        included = {DiskType.HDD, DiskType.SSD, DiskType.NVME}
    if not excluded:
        excluded = set()

    # Check invalid filters.
    if included.intersection(excluded):
        raise ValueError(&#34;Parameter error: same value on included and excluded list.&#34;)

    # Collect selected disks based on the specified filters.
    for disk in self.__disk_list:
        disk_type = disk.get_type()
        if disk_type in included and disk_type not in excluded:
            result.append(disk)

    # Sort the result list if needed.
    if sorting:
        result.sort(reverse=rev_order)

    return result</code></pre>
</details>
</dd>
<dt id="disk_info.DiskInfo.get_disk_number"><code class="name flex">
<span>def <span class="ident">get_disk_number</span></span>(<span>self, included: set = None, excluded: set = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of the disks. The caller can specify inclusive and exclusice filters for disk types.
If no filters are specified then the default behaviour is to include all disk types and to exclude nothing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>included</code></strong> :&ensp;<code>set</code></dt>
<dd>filter set for included disk types</dd>
<dt><strong><code>excluded</code></strong> :&ensp;<code>set</code></dt>
<dd>filter set for excluded disk types</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>number of the (filtered) disks</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if there are common disk types on included and excluded filter sets</dd>
</dl>
<h2 id="example">Example</h2>
<p>A code example about using filters: it counts the number of SSDs excluding NVME disks.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from disk_info import DiskType, DiskInfo
&gt;&gt;&gt; di = DiskInfo()
&gt;&gt;&gt; n = di.get_disk_number(included={DiskType.SSD}, excluded={DiskType.NVME})
&gt;&gt;&gt; print(f&quot;Number of SSDs: {n}&quot;)
Number of SSDs: 3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_disk_number(self, included: set = None, excluded: set = None) -&gt; int:
    &#34;&#34;&#34;Returns the number of the disks. The caller can specify inclusive and exclusice filters for disk types.
    If no filters are specified then the default behaviour is to include all disk types and to exclude nothing.

    Args:
        included (set): filter set for included disk types
        excluded (set): filter set for excluded disk types
    Returns:
        int: number of the (filtered) disks
    Raises:
        ValueError: if there are common disk types on included and excluded filter sets
    Example:
        A code example about using filters: it counts the number of SSDs excluding NVME disks.

        &gt;&gt;&gt; from disk_info import DiskType, DiskInfo
        &gt;&gt;&gt; di = DiskInfo()
        &gt;&gt;&gt; n = di.get_disk_number(included={DiskType.SSD}, excluded={DiskType.NVME})
        &gt;&gt;&gt; print(f&#34;Number of SSDs: {n}&#34;)
        Number of SSDs: 3
    &#34;&#34;&#34;
    disk_number: int    # Number of disk counted

    # Set default filters if not specified.
    if not included:
        included = {DiskType.HDD, DiskType.SSD, DiskType.NVME}
    if not excluded:
        excluded = set()

    # Check invalid filters.
    if included.intersection(excluded):
        raise ValueError(&#34;Parameter error: same value on included and excluded list.&#34;)

    # Count number of disks based on the specified filters.
    disk_number = 0
    for disk in self.__disk_list:
        disk_type = disk.get_type()
        if disk_type in included and disk_type not in excluded:
            disk_number += 1

    return disk_number</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="disk_info.DiskType"><code class="flex name class">
<span>class <span class="ident">DiskType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Constant values for disk types and for their names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DiskType:
    &#34;&#34;&#34;Constant values for disk types and for their names.&#34;&#34;&#34;
    HDD = 1
    &#34;&#34;&#34;Hard disk type.&#34;&#34;&#34;
    SSD = 2
    &#34;&#34;&#34;SSD disk type.&#34;&#34;&#34;
    NVME = 4
    &#34;&#34;&#34;NVME disk type.&#34;&#34;&#34;
    HDD_STR = &#34;HDD&#34;
    &#34;&#34;&#34;Hard disk type name.&#34;&#34;&#34;
    SSD_STR = &#34;SSD&#34;
    &#34;&#34;&#34;SSD disk type name.&#34;&#34;&#34;
    NVME_STR = &#34;NVME&#34;
    &#34;&#34;&#34;NVME disk type name.&#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="disk_info.DiskType.HDD"><code class="name">var <span class="ident">HDD</span></code></dt>
<dd>
<div class="desc"><p>Hard disk type.</p></div>
</dd>
<dt id="disk_info.DiskType.HDD_STR"><code class="name">var <span class="ident">HDD_STR</span></code></dt>
<dd>
<div class="desc"><p>Hard disk type name.</p></div>
</dd>
<dt id="disk_info.DiskType.NVME"><code class="name">var <span class="ident">NVME</span></code></dt>
<dd>
<div class="desc"><p>NVME disk type.</p></div>
</dd>
<dt id="disk_info.DiskType.NVME_STR"><code class="name">var <span class="ident">NVME_STR</span></code></dt>
<dd>
<div class="desc"><p>NVME disk type name.</p></div>
</dd>
<dt id="disk_info.DiskType.SSD"><code class="name">var <span class="ident">SSD</span></code></dt>
<dd>
<div class="desc"><p>SSD disk type.</p></div>
</dd>
<dt id="disk_info.DiskType.SSD_STR"><code class="name">var <span class="ident">SSD_STR</span></code></dt>
<dd>
<div class="desc"><p>SSD disk type name.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#how-to-use">How to use</a><ul>
<li><a href="#option-1-collect-information-about-a-disk">Option 1: collect information about a disk</a></li>
<li><a href="#option-2-discover-disks">Option 2: discover disks</a></li>
</ul>
</li>
<li><a href="#persistent-disk-names">Persistent disk names</a></li>
<li><a href="#demo">Demo</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="disk_info.demo" href="demo.html">disk_info.demo</a></code></li>
<li><code><a title="disk_info.disk" href="disk.html">disk_info.disk</a></code></li>
<li><code><a title="disk_info.disk_info" href="disk_info.html">disk_info.disk_info</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="disk_info.Disk" href="#disk_info.Disk">Disk</a></code></h4>
<ul class="">
<li><code><a title="disk_info.Disk.get_byid_path" href="#disk_info.Disk.get_byid_path">get_byid_path</a></code></li>
<li><code><a title="disk_info.Disk.get_bypath_path" href="#disk_info.Disk.get_bypath_path">get_bypath_path</a></code></li>
<li><code><a title="disk_info.Disk.get_dev_id" href="#disk_info.Disk.get_dev_id">get_dev_id</a></code></li>
<li><code><a title="disk_info.Disk.get_firmware" href="#disk_info.Disk.get_firmware">get_firmware</a></code></li>
<li><code><a title="disk_info.Disk.get_logical_block_size" href="#disk_info.Disk.get_logical_block_size">get_logical_block_size</a></code></li>
<li><code><a title="disk_info.Disk.get_model" href="#disk_info.Disk.get_model">get_model</a></code></li>
<li><code><a title="disk_info.Disk.get_name" href="#disk_info.Disk.get_name">get_name</a></code></li>
<li><code><a title="disk_info.Disk.get_partition_table_type" href="#disk_info.Disk.get_partition_table_type">get_partition_table_type</a></code></li>
<li><code><a title="disk_info.Disk.get_partition_table_uuid" href="#disk_info.Disk.get_partition_table_uuid">get_partition_table_uuid</a></code></li>
<li><code><a title="disk_info.Disk.get_path" href="#disk_info.Disk.get_path">get_path</a></code></li>
<li><code><a title="disk_info.Disk.get_physical_block_size" href="#disk_info.Disk.get_physical_block_size">get_physical_block_size</a></code></li>
<li><code><a title="disk_info.Disk.get_serial" href="#disk_info.Disk.get_serial">get_serial</a></code></li>
<li><code><a title="disk_info.Disk.get_size" href="#disk_info.Disk.get_size">get_size</a></code></li>
<li><code><a title="disk_info.Disk.get_size_in_hrf" href="#disk_info.Disk.get_size_in_hrf">get_size_in_hrf</a></code></li>
<li><code><a title="disk_info.Disk.get_type" href="#disk_info.Disk.get_type">get_type</a></code></li>
<li><code><a title="disk_info.Disk.get_type_str" href="#disk_info.Disk.get_type_str">get_type_str</a></code></li>
<li><code><a title="disk_info.Disk.get_wwn" href="#disk_info.Disk.get_wwn">get_wwn</a></code></li>
<li><code><a title="disk_info.Disk.is_hdd" href="#disk_info.Disk.is_hdd">is_hdd</a></code></li>
<li><code><a title="disk_info.Disk.is_nvme" href="#disk_info.Disk.is_nvme">is_nvme</a></code></li>
<li><code><a title="disk_info.Disk.is_ssd" href="#disk_info.Disk.is_ssd">is_ssd</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="disk_info.DiskInfo" href="#disk_info.DiskInfo">DiskInfo</a></code></h4>
<ul class="">
<li><code><a title="disk_info.DiskInfo.get_disk_list" href="#disk_info.DiskInfo.get_disk_list">get_disk_list</a></code></li>
<li><code><a title="disk_info.DiskInfo.get_disk_number" href="#disk_info.DiskInfo.get_disk_number">get_disk_number</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="disk_info.DiskType" href="#disk_info.DiskType">DiskType</a></code></h4>
<ul class="two-column">
<li><code><a title="disk_info.DiskType.HDD" href="#disk_info.DiskType.HDD">HDD</a></code></li>
<li><code><a title="disk_info.DiskType.HDD_STR" href="#disk_info.DiskType.HDD_STR">HDD_STR</a></code></li>
<li><code><a title="disk_info.DiskType.NVME" href="#disk_info.DiskType.NVME">NVME</a></code></li>
<li><code><a title="disk_info.DiskType.NVME_STR" href="#disk_info.DiskType.NVME_STR">NVME_STR</a></code></li>
<li><code><a title="disk_info.DiskType.SSD" href="#disk_info.DiskType.SSD">SSD</a></code></li>
<li><code><a title="disk_info.DiskType.SSD_STR" href="#disk_info.DiskType.SSD_STR">SSD_STR</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>